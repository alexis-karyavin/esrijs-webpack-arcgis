{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { loader } from 'webpack';\nimport { createInstrumenter } from 'istanbul-lib-instrument';\nimport { getOptions } from 'loader-utils';\nimport {\n\tRawSourceMap,\n\tMappedPosition,\n\tMappingItem,\n\tSourceMapConsumer,\n\tSourceMapGenerator\n} from 'source-map';\nimport { getConfig } from 'intern/lib/node/util';\n\n/**\n * Instrument a source file with istanbul for code coverage.\n *\n * Instrumenter options will be read from the project 'intern.json' file.\n *\n * @param content the source code\n * @param sourceMap an optional source map\n */\nexport default <loader.Loader>function(\n\tsource: string | Buffer,\n\t// TODO: remove 'any' when webpack typings are updated\n\tsourceMap?: any\n) {\n\tconst callback = this.async()!;\n\tconst options = Object.assign({}, getOptions(this));\n\n\t// TODO remove this and just use `sourceMap` when webpack typings are\n\t// updated\n\tconst _sourceMap = <RawSourceMap>sourceMap;\n\n\tgetConfig(options.config)\n\t\t.then(({ config, file }) => {\n\t\t\t// If a config file was successfully loaded, mark it as a dependency\n\t\t\tif (file) {\n\t\t\t\tthis.addDependency(file);\n\t\t\t}\n\t\t\treturn config;\n\t\t})\n\t\t.catch(_error => Object.create(null))\n\t\t.then(config => {\n\t\t\tconst instrumenterOptions = {\n\t\t\t\tproduceSourceMap: true,\n\t\t\t\t...config.instrumenterOptions\n\t\t\t};\n\n\t\t\tif (config.coverageVariable) {\n\t\t\t\tinstrumenterOptions.coverageVariable = config.coverageVariable;\n\t\t\t}\n\n\t\t\tconst instrumenter = createInstrumenter(instrumenterOptions);\n\n\t\t\t// For the code coverage to work we need to modify the sources in the\n\t\t\t// source map to point back to the original file. The files coming in have\n\t\t\t// been generated by webpack and look like,\n\t\t\t// \"node_modules/tslint-loader?!path/to/file/css-modules!path/to/file.ts.\n\t\t\t// We need these files to simply be \"path/to/file.ts\".\n\t\t\tif (_sourceMap) {\n\t\t\t\t_sourceMap.sources = (_sourceMap.sources || []).map(source => {\n\t\t\t\t\tconst lastBang = source.lastIndexOf('!');\n\t\t\t\t\tif (lastBang !== -1) {\n\t\t\t\t\t\treturn source.substr(lastBang + 1);\n\t\t\t\t\t}\n\t\t\t\t\treturn source;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tinstrumenter.instrument(\n\t\t\t\tString(source),\n\t\t\t\tthis.resourcePath,\n\t\t\t\t(error, instrumentedSource) => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tcallback(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst instrumentedSourceMap = instrumenter.lastSourceMap();\n\t\t\t\t\t\t\tlet updatedSourceMap: RawSourceMap;\n\t\t\t\t\t\t\tif (_sourceMap) {\n\t\t\t\t\t\t\t\tupdatedSourceMap = mergeSourceMaps(\n\t\t\t\t\t\t\t\t\tinstrumentedSourceMap,\n\t\t\t\t\t\t\t\t\t_sourceMap\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tupdatedSourceMap = instrumentedSourceMap;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcallback(\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\tinstrumentedSource,\n\t\t\t\t\t\t\t\t// TODO: remove 'any' when webpack typings are\n\t\t\t\t\t\t\t\t// updated\n\t\t\t\t\t\t\t\t<any>updatedSourceMap\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t_sourceMap\n\t\t\t);\n\t\t});\n};\n\n/**\n * Merge a list of source maps generated through successive transforms of a\n * single file.\n *\n * Maps should be in reverse order (i.e., the first map should be\n * from the most recent transform).\n *\n * @param maps an array of raw source maps in order from the most recently\n * generated map to the original map\n * @returns a source map that maps locations in the final transformed file to\n * the original file\n */\nfunction mergeSourceMaps(...maps: RawSourceMap[]) {\n\tconst consumers = maps.map(map => new SourceMapConsumer(map));\n\tconst generator = new SourceMapGenerator({ file: maps[0].file });\n\n\t// Walk through each mapping of the most recent source map\n\tconsumers[0].eachMapping(mapping => {\n\t\tconst original = getOriginalPosition(consumers, mapping);\n\t\tif (original.line !== null) {\n\t\t\tgenerator.addMapping({\n\t\t\t\tgenerated: {\n\t\t\t\t\tline: mapping.generatedLine,\n\t\t\t\t\tcolumn: mapping.generatedColumn!\n\t\t\t\t},\n\t\t\t\toriginal: {\n\t\t\t\t\tline: original.line,\n\t\t\t\t\tcolumn: original.column!\n\t\t\t\t},\n\t\t\t\tsource: mapping.source!,\n\t\t\t\tname: mapping.name\n\t\t\t});\n\t\t}\n\t});\n\n\treturn <RawSourceMap>JSON.parse(generator.toString());\n}\n\n/**\n * Find the original position for a given position.\n *\n * @param consumers a list of source map consumers, from the most recently\n * generated to the original\n * @param mapping a mapping item from the most recent source map\n * @returns a position in the original file\n */\nfunction getOriginalPosition(\n\tconsumers: SourceMapConsumer[],\n\tmapping: MappingItem\n) {\n\treturn consumers.reduce(\n\t\t(original, consumer) => {\n\t\t\t// Ignore missing mappings\n\t\t\tif (isMappedPosition(original)) {\n\t\t\t\treturn consumer.originalPositionFor(original);\n\t\t\t}\n\t\t\treturn original;\n\t\t},\n\t\t{\n\t\t\tline: mapping.generatedLine,\n\t\t\tcolumn: mapping.generatedColumn\n\t\t}\n\t);\n}\n\n/**\n * Indicate whether the given value is a MappedPosition\n */\nfunction isMappedPosition(position: any): position is MappedPosition {\n\treturn (\n\t\tposition.line != null &&\n\t\tposition.column != null &&\n\t\tposition.source != null\n\t);\n}\n"]}